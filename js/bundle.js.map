{"version":3,"sources":["webpack/bootstrap 6443100e224b0e7d70bf","./js/main.js","./js/snake-view.js","./js/snake.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACND;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB,qBAAqB;AACtC;AACA,oBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;ACnGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;;AAEA,kBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;;AAEA,kBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,kBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kBAAiB,UAAU;AAC3B;AACA,oBAAmB,UAAU;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/js/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6443100e224b0e7d70bf\n **/","var SnakeView = require('./snake-view');\n\n$(function () {\n  var el = $('.snake-game');\n  var rootEl = $('.root');\n  new SnakeView(el, rootEl);\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/main.js\n ** module id = 0\n ** module chunks = 0\n **/","var Board = require('./snake.js');\n\nvar View = function ($el, $rootEl) {\n  this.$el = $el;\n  this.$rootEl = $rootEl;\n\n  this.board = new Board(20);\n  this.setupGrid();\n\n  this.paused = false;\n  this.interval = window.setInterval(this.step.bind(this), 100);\n  this.pause();\n\n  $(window).on(\"keydown\", this.handleKeyEvent.bind(this));\n};\n\nView.KEYS = {\n  32: \"P\",\n  38: \"N\",\n  39: \"E\",\n  40: \"S\",\n  37: \"W\"\n};\n\nView.prototype.handleKeyEvent = function (event) {\n  var input = View.KEYS[event.keyCode];\n  if (input === \"N\" || input === \"E\" || input === \"S\" || input === \"W\") {\n    this.board.snake.turn(input);\n  } else if (input === \"P\") {\n    this.pause();\n  }\n};\n\nView.prototype.pause = function () {\n  $(\".paused\").toggleClass(\"show\");\n\n  // Toggle pause state\n  this.paused = (this.paused ? false : true);\n\n  if (this.paused) {\n    window.clearInterval(this.interval);\n  } else {\n    this.interval = window.setInterval(this.step.bind(this), 100);\n  }\n};\n\nView.prototype.render = function () {\n  this.updateClasses(this.board.snake.segments, \"snake\");\n  this.updateClasses(this.board.computer.segments, \"computer\");\n  this.updateClasses([this.board.apple.position], \"apple\");\n};\n\nView.prototype.updateClasses = function (coordinates, className) {\n  this.$li.filter(\".\" + className).removeClass();\n\n  coordinates.forEach( function (coordinate) {\n    var flatCoordinate = (coordinate.a * this.board.size) + coordinate.b;\n    this.$li.eq(flatCoordinate).addClass(className);\n  }.bind(this));\n};\n\nView.prototype.updateScore = function (score) {\n  $('.score').html( \"Score: \" + this.board.snake.score);\n};\n\nView.prototype.setupGrid = function () {\n  var html = \"\";\n\n  for (var i = 0; i < this.board.size; i++) {\n    html += \"<ul>\";\n    for (var j = 0; j < this.board.size; j++) {\n      html += \"<li></li>\";\n    }\n    html += \"</ul>\";\n  }\n\n  this.$el.html(html);\n  this.$li = this.$el.find(\"li\");\n};\n\nView.prototype.step = function () {\n  if (\n    this.board.snake.segments.length > 0 &&\n    this.board.computer.segments.length > 0\n  ) {\n    this.board.snake.move();\n    this.board.computer.pickDirection();\n    this.board.computer.move();\n    this.render();\n    this.updateScore(this.board.snake.score);\n  } else if (this.board.computer.segments.length === 0) {\n    alert(\"You win!\");\n    window.clearInterval(this.interval);\n  } else if (this.board.snake.segments.length === 0) {\n    alert(\"You lose!\");\n    window.clearInterval(this.interval);\n  }\n};\n\nmodule.exports = View;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/snake-view.js\n ** module id = 1\n ** module chunks = 0\n **/","var Coordinate = function (a, b) {\n  this.a = a;\n  this.b = b;\n};\n\nCoordinate.prototype.isOpposite = function (coordinate) {\n  return (this.a === (-1 * coordinate.a) && this.b === (-1 * coordinate.b));\n};\n\nCoordinate.prototype.plus = function (coordinate) {\n  return new Coordinate(this.a + coordinate.a, this.b + coordinate.b);\n};\n\nCoordinate.prototype.equals = function (coordinate) {\n  return (this.a === coordinate.a) && (this.b === coordinate.b);\n};\n\nvar Apple = function (board) {\n  this.board = board;\n  this.replace();\n};\n\nApple.SYMBOL = \"A\";\n\nApple.prototype.replace = function () {\n  var x = Math.floor(Math.random() * this.board.size);\n  var y = Math.floor(Math.random() * this.board.size);\n\n  while (\n    this.board.snake.isOccupying([x, y]) ||\n    this.board.computer.isOccupying([x, y])\n  ) {\n    x = Math.floor(Math.random() * this.board.size);\n    y = Math.floor(Math.random() * this.board.size);\n  }\n\n  this.position = new Coordinate(x, y);\n};\n\nvar Snake = function (board, type) {\n  this.direction = \"N\";\n  this.turning = false;\n  this.board = board;\n  this.type = type;\n\n  var center;\n  if (this.type === \"human\") {\n    center = new Coordinate(\n      Math.floor(board.size * (3/4)), Math.floor(board.size * (1/4))\n    );\n  } else {\n    center = new Coordinate(\n      Math.floor(board.size * (3/4)), Math.floor(board.size * (3/4))\n    );\n  }\n  this.segments = [center];\n\n  this.growTurns = 0;\n  this.score = 0;\n};\n\nSnake.DIFFERENCE = {\n  \"N\": new Coordinate(-1, 0),\n  \"S\": new Coordinate(1, 0),\n  \"E\": new Coordinate(0, 1),\n  \"W\": new Coordinate(0, -1)\n};\n\nSnake.SYMBOL = \"S\";\nSnake.GROW_TURNS = 3;\nSnake.APPLE_POINTS = 10;\n\nSnake.prototype.eatApple = function () {\n  if (this.head().equals(this.board.apple.position)) {\n    this.growTurns += Snake.GROW_TURNS;\n    this.score += Snake.APPLE_POINTS;\n    return true;\n  } else {\n    return false;\n  }\n};\n\nSnake.prototype.isOccupying = function (array) {\n  var result = false;\n  this.segments.forEach( function (segment) {\n    if (segment.a === array[0] && segment.b === array[1]) {\n      result = true;\n      return result;\n    }\n  });\n  return result;\n};\n\nSnake.prototype.head = function () {\n  var last = this.segments.length - 1;\n  return this.segments[last];\n};\n\nSnake.prototype.isValid = function (enemySegments) {\n  var head = this.head();\n\n  if (!this.board.validPosition(this.head())) {\n    return false;\n  }\n\n  for (var i = 0; i < this.segments.length - 1; i++) {\n    if (this.segments[i].equals(head)) {\n      return false;\n    }\n  }\n\n  for (var j = 0; j < enemySegments.length; j++) {\n    if (enemySegments[j].equals(head)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nSnake.prototype.move = function () {\n  // Move snake forward by adding a new segment in the direction the snake\n  // is traveling in.\n  var newSegment = this.head().plus(Snake.DIFFERENCE[this.direction]);\n  this.segments.push(newSegment);\n\n  // Allow snake to turn again\n  this.turning = false;\n\n  // Check for contact with apple\n  if (this.eatApple()) {\n    this.board.apple.replace();\n  }\n\n  // Remove tail segment if not growing\n  if (this.growTurns > 0) {\n    this.growTurns -= 1;\n  } else {\n    this.segments.shift();\n  }\n\n  // Destroy snake if collides with wall or self\n  var enemySegments;\n  if (this.type === \"human\") {\n    enemySegments = this.board.computer.segments;\n  } else {\n    enemySegments = this.board.snake.segments;\n  }\n  if (!this.isValid(enemySegments)) {\n    this.segments = [];\n  }\n};\n\nSnake.prototype.turn = function (direction) {\n  if (\n    Snake.DIFFERENCE[this.direction].isOpposite(Snake.DIFFERENCE[direction]) ||\n    this.turning\n  ) {\n    return;\n  } else {\n    this.turning = true;\n    this.direction = direction;\n  }\n};\n\nSnake.prototype.pickDirection = function () {\n  var board = this.board;\n  var appleX = board.apple.position.b;\n  var headX = board.computer.head().b;\n  var currentDirection = board.computer.direction;\n\n\n  // Compare apple X position with snake head X position\n  var xComparison;\n  if (headX < appleX) {\n    xComparison = -1;\n  } else if (headX === appleX) {\n    xComparison = 0;\n  } else if (headX > appleX) {\n    xComparison = 1;\n  }\n\n  // Decision making logic for computer snake: Move towards X-Coordinate of\n  // apple, unless that direction is opposite current direction,\n  // in which snake should move towards Y-Coordinate of apple.\n  switch (xComparison) {\n    case -1:\n      this.dueEast();\n    break;\n    case 0:\n      this.dueNorthOrSouth();\n    break;\n    case 1:\n      this.dueWest();\n    break;\n  }\n};\n\nSnake.prototype.dueEast = function () {\n  var board = this.board;\n  var currentDirection = board.computer.direction.slice();\n  var appleY = board.apple.position.a;\n  var headY = board.computer.head().a;\n  if (currentDirection === \"W\")  {\n    this.direction = (headY > appleY ? \"S\" : \"N\");\n  } else {\n    this.direction = \"E\";\n  }\n\n  if (this.pathBlocked()) {\n    this.direction = this.alternatePath(currentDirection);\n  }\n};\n\nSnake.prototype.dueNorthOrSouth = function () {\n  var board = this.board;\n  var currentDirection = board.computer.direction.slice();\n  var appleY = board.apple.position.a;\n  var headY = board.computer.head().a;\n  if (headY > appleY && currentDirection !== \"S\") {\n    this.direction = \"N\";\n  } else if (headY < appleY && currentDirection !== \"N\") {\n    this.direction = \"S\";\n  } else {\n    this.direction = \"E\";\n  }\n\n  if (this.pathBlocked()) {\n    this.direction = this.alternatePath(currentDirection);\n  }\n};\n\nSnake.prototype.dueWest = function () {\n  var board = this.board;\n  var currentDirection = board.computer.direction.slice();\n  var appleY = board.apple.position.a;\n  var headY = board.computer.head().a;\n  if (currentDirection === \"E\") {\n    this.direction = (headY > appleY ? \"S\" : \"N\");\n  } else {\n    this.direction = \"W\";\n  }\n\n  if (this.pathBlocked()) {\n    this.direction = this.alternatePath(currentDirection);\n  }\n};\n\nSnake.prototype.pathBlocked = function () {\n  var spaceAhead = this.head().plus(Snake.DIFFERENCE[this.direction]);\n  var enemySegments = this.board.snake.segments;\n\n  if (!this.board.validPosition(spaceAhead)) {\n    return true;\n  }\n\n  for (var i = 0; i < this.segments.length - 1; i++) {\n    if (this.segments[i].equals(spaceAhead)) {\n      return true;\n    }\n  }\n\n  for (var j = 0; j < enemySegments.length; j++) {\n    if (enemySegments[j].equals(spaceAhead)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nSnake.prototype.alternatePath = function (currentDirection) {\n  // Remove ivalid directions from all possible directions\n  var alternatives = [\"N\", \"S\", \"E\", \"W\"];\n  var oppositeDirectionIndex = alternatives.findIndex( function (element) {\n    return element === this.oppositeDirection(currentDirection);\n  }.bind(this));\n  alternatives.splice(oppositeDirectionIndex, 1);\n  var invalidDirectionIndex = alternatives.findIndex( function (element) {\n    return element === this.direction;\n  }.bind(this));\n  alternatives.splice(invalidDirectionIndex, 1);\n  // return the first direction whose path is not blocked\n  for (var i = 0; i < alternatives.length; i++) {\n    this.direction = alternatives[i];\n    if (!this.pathBlocked()) {\n      return alternatives[i];\n    }\n  }\n\n  return currentDirection;\n};\n\nSnake.prototype.oppositeDirection = function (direction) {\n  switch (direction) {\n    case \"N\":\n      return \"S\";\n    case \"S\":\n      return \"N\";\n    case \"E\":\n      return \"W\";\n    case \"W\":\n      return \"E\";\n  }\n};\n\nvar Board = function (size) {\n  this.size = size;\n\n  this.snake = new Snake(this, \"human\");\n  this.computer = new Snake(this, \"computer\");\n  this.apple = new Apple(this);\n};\n\nBoard.BLANK_SYMBOL = \".\";\n\nBoard.blankGrid = function (size) {\n  var grid = [];\n\n  for (var i = 0; i < size; i++) {\n    var row = [];\n    for (var j = 0; j < size; j++) {\n      row.push(Board.BLANK_SYMBOL);\n    }\n    grid.push(row);\n  }\n\n  return grid;\n};\n\nBoard.prototype.render = function () {\n  var grid = Board.blankGrid(this.size);\n\n  this.snake.segments.forEach( function (segment) {\n    grid[segment.a][segment.b] = Snake.SYMBOL;\n  });\n\n  grid[this.apple.position.a][this.apple.position.b] = Apple.SYMBOL;\n\n  var rowStrs = [];\n  grid.map( function (row) {\n    return row.join(\"\");\n  }).join(\"\\n\");\n};\n\nBoard.prototype.validPosition = function (coordinate) {\n  return (\n    (coordinate.a >= 0) &&\n    (coordinate.a < this.size) &&\n    (coordinate.b >= 0) &&\n    (coordinate.b < this.size)\n  );\n};\n\nmodule.exports = Board;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./js/snake.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}